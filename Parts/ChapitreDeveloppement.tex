\chapter{Développement}
Après avoir détaillé la représentation des données de ce projet, nous étudierons dans ce chapitre les différentes technologies utilisées dans l'implémentation ainsi que l'architecture utilisée. Nous détaillerons ensuite les formats et modèles de nos données. Enfin, nous donnerons un aperçu des applications front-end.
\section{Technologies utilisées}
\subsection{NodeJs}
Aux alentours de 2010 Google a commencé à rendre JavaScript et son moteur d'exécution V8 plus rapides. Des outils comme Nodejs sont ensuite apparus\cite{NodeJs}.\newline
Node.js est un environnement d'exécution \textbf{JavaScript} construit sur le moteur \emph{V8} de Google Chrome. Il utilise un modèle basé sur l'événementiel (\textbf{event-driven}) et des entrées/sorties non bloquantes, ce qui le rend léger et efficace.
Il présente plusieurs avantages, notamment :
\begin{itemize}
	\item NodeJs et son écosystème permettent de travailler avec JavaScript à la fois sur le frontend et le backend.
	\item L'approche non bloquante de NodeJs lui permet d'effectuer des entrées/sorties (I/O) de manière asynchrone. La programmation asynchrone est idéal pour une exécution plus rapide de programmes.
	\item Contrairement aux langages serveur célèbres tel que PHP, ASP.NET, Ruby ou Java, NodeJs s'exécute en \emph{monothread}, en d'autres termes les processus de chaque requête sont traités dans un seul fil d'exécution, ce qui est très efficace en termes de mémoire.
	\item NodeJs rassemble une grande communauté très active, ce qui offre un grand nombre de librairies et de support en travaillant avec NodeJs.\newline
\end{itemize}

\textbf{ExpressJs :} un framework\FancyFootNote{Framework : C'est une sorte d'infrastructure de développement, il désigne un ensemble cohérent de composants logiciels structurels qui sert à créer les fondations ainsi que les grandes lignes de tout ou d'une partie d'un logiciel ou application.} d'application minimaliste et très flexible qui propose un ensemble de fonctionnalités stables pour les applications web, en l'occurrence l'implémentation des APIs (Express.Router). Au moment d'écrire ce rapport, c'est l'outil le plus connu et le plus utilisé avec NodeJs.

NodeJs est donc un choix idéal pour développer des APIs REST minimales et flexibles tout en gardant des performances élevées pendant le traitement de requêtes.\newline
En dernier, bien que NodeJs ne soit pas adapté pour des applications aux calculs intensifs, il ne sera pas un inconvénient du fait que les calculs sur le graphe seront effectués principalement dans le SGBD.
\subsection{MongoDB}
	MongoDB \cite{MongoDB} est un système de base de données NoSQL. Il est orienté documents qui est une évolution des simples bases de données clé-valeur. Un document peut être une valeur atomique, paire clé-valeur, un tableau de valeurs ou une compositions de ces derniers.

Son nom vient de Humongous qui veut dire énorme ou immense. Il est capable de gérer de très grandes quantités de données avec une grande facilité d'extension, ses principaux avantages sont:

\begin{itemize}
	\item Stockage flexible de données sous forme de documents semi-structurés (similaires au JSON), les attributs peuvent varier de document à document et la structure peut changer au fil du temps.
	\item Facilité de manipulation depuis l'application: MongoDB transforme les documents en objets qui peuvent être manipulés avec le langage de programmation utilisé.
	\item Existence de méthodes puissantes pour accéder et analyser les données.
\end{itemize}

En résumé, MongoDB est un SGBD très flexible et simple à utiliser, nous stockerons les informations supplémentaires de notre application en utilisant ce système, tel que les Bus, horaires,...etc.

\subsection{Neo4j}
Apparu en l'année 2000 et appartient à la société Neo Technology, Neo4j \cite{Neo4j} est un système de gestion de bases de données (SGBD) orienté graphe. Son approche est fondée sur la théorie des graphes. Les données sont stockées de manière assez libre (sans modèle prédéfini) dans des nœuds reliés entre eux par des relations.

Ses principaux avantages sont :
\begin{itemize}
	\item Neo4j utilise un stockage natif du graphe, avec un principe appelé \textbf{index-free adjacency}, ceci permet de stocker des nœuds directement avec ses relations et nœuds adjacents sans avoir à utiliser des indexes pour consulter ses relations.\newline
	Le stockage natif offre de très grandes performances de lecture/écriture indépendamment de la taille du graphe (le temps d'accès à chaque noeud est constant).
	\item Neo4j est open-source, et a la plus grande communauté dans les bases de données orientées graphe, qui contribuent constamment à son écosystème, ce qui donne un très grand nombre de ressources et de support ainsi qu'une grande liste de pilotes et librairies dans tous les langages courants.
	\item Neo4j se présente comme une solution dans un très grand nombre de cas d'utilisations, par exemple: Réseaux sociaux, détection de fraude, Réseaux et opérations IT...etc.
	\item Facile à apprendre et à utiliser: Neo4j dispose d'une interface graphique très moderne et riche, et utilise son propre langage d'interrogation Cypher.\newline
\end{itemize}

Neo4j étant le SGBD le plus dominant dans le domaine des SGBD orientés graphe, et offrant une grande performance et flexibilité qui satisfait tous les besoins de ce projet. Nous n'avons pas eu besoin de considérer les autres systèmes.

\textbf{Cypher: } c'est un langage de requête déclaratif sur Neo4j. Il permet de décrire la forme du résultat et les contraintes souhaitées à ajouter en optimisant le plan d'exécution pour récupérer les résultats.\newline

Il utilise une syntaxe déclarative similaire au SQL, avec de l'ASCII Art (des figures et signes utilisant des lettres et caractères spéciaux) pour décrire les nœuds et les relations, rendant les requêtes faciles à lire et comprendre. Un exemple est donné dans la figue \ref{fig:cypher}.

\begin{figure}
	\center
	\includegraphics[width=0.8\textwidth]{img/cypher.png}
	\caption{Exemple de requête Cypher.}
	\label{fig:cypher}
\end{figure}

\subsection{VueJs}
VueJs\cite{VueJs} est un framework évolutif pour construire des interfaces utilisateur. Il a été conçu et pensé pour pouvoir être adopté de manière incrémentale. Le cœur de la bibliothèque est concentré uniquement sur la partie vue, le reste (Routage, gestion d'état...) étant fourni dans des bibliothèques complémentaires, et il est simple de l'intégrer avec d'autres bibliothèques ou projets existants. 
Il est tout à fait capable de faire tourner des applications web monopages (Single Page Applications) très complexes lorsqu'il est combiné avec d'autres outils modernes et ses bibliothèques complémentaires.\newline
Ses principaux avantages sont : 
\begin{itemize}
	\item Très petit de taille et facile à apprendre: possible de commencer le développement avec VueJs rapidement sans avoir à connaitre toutes les fonctionnalités avancées dès le départ.
	\item Très bien documenté avec une communauté active.
	\item Flexible et offre de très bonne performances, c'est un des framework les plus rapides en ce moment.
\end{itemize}

Il est très difficile de comparer les framework front-end, chacune a ses points forts et toutes peuvent accomplir le même résultat. Nous avons opté pour VueJs à raison de sa grande flexibilité et la facilité de commencer avec, qui nous a permis de tester rapidement plusieurs outils et fonctionnalités avant d'atteindre le résultat donné dans la section \ref{ref:Implementation}.

\section{Structure de l'application}
\subsection{L'architecture MVC (Model-View-Controller)}
L'architecture MVC est un modèle d'architecture qui sépare une application en 3 composants logiques: \textbf{Model}, \textbf{View}, \textbf{Controller}.
Chaque composant est construit pour gérer un aspect spécifique de l'application, on peut résumer le rôle de chacun comme suit :
\begin{enumerate}
	\item \textbf{Models: } ces composants correspondent à tout ce qui est relié aux données, un model peut représenter une classe d'objets ou une structure de données échangée entre Views et Controllers, ainsi que la logique manipulant ces données telle que des calculs de moyennes ou les différentes opérations d'ajout, modification et suppression dans une base de données.
	\item \textbf{Views:} les views sont utilisés pour l'interface utilisateur (UI) de l'application, ceci inclut les composants d'interface (textes, boutons, formulaires...etc.), ainsi que certaines logiques de mise en forme et affichage des données.
	\item \textbf{Controller: } le Controller joue le rôle d'une interface entre le Model et les Views afin de traiter les requêtes venant du View (par exemple un clique de bouton), manipuler les données du Model et enfin les rendre au View pour qu'elles soient présentées. il contient généralement la logique des actions effectuées par l'utilisateur.
\end{enumerate}
	
MVC est une des architectures les plus utilisées pour créer des projets évolutifs et extensibles \cite{refMVC}.
%Il existe plusieurs variantes du MVC et d'autres architectures similaires tel que le MVVM (Model-View-ViewModel) et le MVP (Model-View-Presenter).

\subsection{Composants de l'application}
L'application suit une architecture MVC décomposée comme suit :
\begin{sidewaysfigure}
	\includegraphics[width=\textwidth]{img/ClassDiagram.png}
	\caption{Vue d'ensemble des composants de l'application}
	\label{fig:classDiagram}
\end{sidewaysfigure}	
\begin{enumerate}
	\item \textbf{Models:}
	      \begin{itemize}
	      	\item \textbf{Station} : représente une station avec son nom, adresse et coordonnées.
	      	\item \textbf{Line} : représente une ligne de transport, le format complet est décrit dans la partie \ref{ref:resources}.
	      	      \begin{itemize}
	      	      	\item \textbf{Bus} : représente un Bus ainsi que les différents facteurs estimés (temps d'attente moyen, fréquence ...etc.).
	      	      \end{itemize}
	      	\item \textbf{Path} : représente une suggestion de chemin, contenant les informations globales tel que le prix et temps total du chemin, ainsi qu'une liste d'objets Step.
	      	      \begin{itemize}
	      	      	\item \textbf{Step} : représente une étape d'un itinéraire utilisant le même moyen de transport, comporte la station de départ et d'arrivée, les stations intermédiaires et les informations sur le temps, coût et distance à parcourir.
	      	      \end{itemize}
	      	      le format de cet objet est détaillé dans la section \ref{ref:formatReponse}
	      	\item \textbf{Models du graphe} : 
	      	      afin d'avoir une application facilement extensible, nous avons séparé les Models relatifs au graphe des Models de l'application, ce qui permettra de modifier la représentation du graphe sans affecter l'application.
	      	      \begin{itemize}
	      	      	\item \textbf{GrapheNode} : représente un nœud, communique avec la base de données pour créer et manipuler les nœuds.
	      	      	\item \textbf{GrapheSegment} : représente un arc entre deux nœuds, communique avec la base de données pour créer plusieurs relations (lignes de transport) ou les supprimer.
	      	      \end{itemize}
	      \end{itemize}
	      	
	\item \textbf{Controller :} dans le cas de notre application, le controller est le \emph{router} de l'application, ce dernier permet de définir les différents points terminaux (endpoints) de l'application et les identifier par une URI, les détails de l'API sont décrits dans la section suivante.
	     	      	
	\item \textbf{Views :} les Views dans ce projet consistent en deux applications séparées : une application client pour demander le chemin et consulter les lignes, et une application administrateur pour insérer et modifier les lignes des différents transports.
	      
	      Ces deux applications sont des \emph{Single Page Applications} : une application dynamique qui tourne sur un navigateur web.
	      Nous ne détaillerons pas l'implémentation de ces applications, car ce n'est pas l'objectif principal de ce projet. Un aperçu du résultat final est donné dans la section \ref{ref:Implementation}.
\end{enumerate}
La relation entre ces composants est décrite dans la figure \ref{fig:classDiagram}.
	
	
\section{Implémentation de l'API}
\label{ref:API}
\subsection{Ressources exposées}
Notre API définit principalement 3 ressources:
\begin{enumerate}
	\item \textbf{Station:} Ressource qui représente les différentes stations du réseau, elle accepte 3 requêtes différentes de type GET  : 
	      \begin{itemize}
	      	\item \emph{\textbf{/api/station}}: retourne toutes les stations, peut être utilisée pour visualiser toutes les stations par un client ou d'autres utilisations générales, le nombre de stations retournées seront limités et contrôlés par deux paramètres \textbf{limit} et \textbf{offset} afin d'éviter de retourner un très grand nombre de stations en une seule requête.
	      	\item \emph{\textbf{/api/station/\{id\}}}: retourne une station par identifiant, le client n'ayant rarement besoin de l'identifiant, cette URI est généralement utilisée du coté administrateur.
	      	\item \emph{\textbf{/api/station?match=\{name\}}}: Un paramètre dans la ressource station permet de retourner toutes les stations dont le nom contient la valeur \emph{name}, peut être utilisé pour la recherche et auto-complétion lors du choix du chemin, par exemple.
	      \end{itemize}
	      	      			
	      Cette ressource accepte aussi des requêtes de type POST (création), PUT (mise à jour) et DELETE (suppression)  pour les client administrateurs (authentifiés).
	\item \textbf{Ligne:} \emph{\textbf{/api/line}} : Ressource qui représente les différentes lignes de transport entre stations, elle accepte des requêtes de type GET du coté client, aussi des requêtes POST, PUT et DELETE du coté administrateur pour gérer les lignes.
	\item \textbf{Direction:}  \emph{\textbf{/api/direction}} : Ressource représentant les chemins, elle accepte seulement des requêtes de type GET, les détails de ces requêtes et leurs réponses sont détaillés dans la section \ref{SectionPathFinding}
\end{enumerate}
\subsection{Description des formats des ressources}
Les ressources principales de notre API sont les stations (\textbf{station}) et les lignes (\textbf{line}), leur format est décrit dans la figure \ref{fig:formatResources}.
\label{ref:resources}

\begin{description}
	\item[Station:] Dans cette version, chaque station contient un identifiant unique, le nom et l'adresse ainsi les coordonnées GPS.
	\item[Line:] Une ligne est identifiée par un ID et un nom, elle contient un lien vers le bus servant cette ligne et une liste des stations de cette ligne contenant l'identifiant, la distance et le temps entre chaque station. Cette ressource  est utilisée principalement pour les requêtes d'ajout du coté administrateur.
\end{description}
% Format JSON 
\lstset{style=JSON}

\begin{figure}[h!]
	%-------------------------------------------------------------------
	\begin{subfigure}[b]{0.45\linewidth}
		\begin{lstlisting}[caption=Format JSON de Station]
{
	ID: 1,
	name: "string",
	address: "string",
	coords: 
	[
	  {
	  	  direction: "string",
  		  lat: 0.00,
   		  lon: 0.00
	  }
	]
}
		\end{lstlisting}
	\end{subfigure}\hfill%  
	%-------------------------------------------------------------------
	\begin{subfigure}[b]{0.45\linewidth}
		\begin{lstlisting}[caption=Format JSON de Line]
{
  "id": 0,
  "name": "string",
  "bus": {
    "name": "string",
    "link": "/api/bus/{id}",
  },
  "lineStations": [
    {
      "stationID": 0,
      "distFromPrev": 0,
      "timeFromPrev": 0
    }
  ]
}
		\end{lstlisting}
	\end{subfigure}\hfill%  
	%-------------------------------------------------------------------
	\caption{Description du format des ressources.}
	\label{fig:formatResources}
\end{figure}


\section{Recherche de chemin}
L'implémentation de l'application du côté serveur permet de calculer un ensemble de chemins optimaux entre deux stations identifiées par un identifiant.
\subsection{Déroulement d'une requête}
\begin{sidewaysfigure}[h!]
	\center
	\includegraphics[width=\textwidth]{img/RechercheChemin.png}
	\caption{Diagramme de séquence pour la recherche de chemins.}
	\label{fig:diagSequence}
\end{sidewaysfigure}

Une requête de recherche d'itinéraire à commencer de la demande de l'utilisateur jusqu'à l'affichage de la réponse passe par plusieurs étapes. Le diagramme de séquence dans la figure \ref{fig:diagSequence} décrit les étapes suivantes :
\begin{enumerate}
	\item L'API reçoit la requête de chemin, vérifie les paramètres et met en forme les données, pour les passer au module qui calcule le chemin (PathFinder).
	\item Le module PathFinder formule la requête Cypher et l'envoi au serveur de la base de données Neo4j. Cette requête est décrite dans la partie \ref{section:cypher}.
	      Nous pouvons depuis cette requête filtrer les différents transports à inclure dans le chemin facilement, puisque chaque moyen de transport est désigné par ses propres arcs étiquetés dans le graphe.
	\item Neo4j retourne ainsi une liste de chemins optimaux, le module va ensuite évaluer chaque chemin :
	      \begin{itemize}
	      	\item Évaluer le temps et coût estimés de chaque chemin.
	      	\item Trier les chemins selon le critère de la requête, en cas d'égalité considérer les autres critères.
	      	\item Structurer chaque chemin en Objets Path, détaillé dans la section suivante.
	      	\item Minimiser le chemin en regroupant les étapes intermédiaires (tel que deux arrêts utilisant le même Bus).
	      \end{itemize}
	\item Retourner l'objet à l'API qui l'envoie sous forme de réponse HTTP, le format de cette réponse est décrit dans la partie \ref{ref:formatReponse}.
\end{enumerate}
\label{SectionPathFinding}
	
\subsection{Requête Cypher}
\label{section:cypher}

La recherche de chemin dans Neo4j est effectuée à travers une requête Cypher. La requête est formulée comme suit :

\begin{itemize}

\item \textbf{Rechercher tous les chemins possibles :}
 \begin{lstlisting}[style=cypher]
MATCH p = AllShortestPaths((A:Station)-[*..100]->(B:Station))
\end{lstlisting}
Cette ligne exprime tous les chemins possibles d'une station A vers une station B en assurant une limite de 100 nœuds actuellement. En y appliquant la fonction \textbf{AllShortestPath}, on obtient une liste de plus courts chemins qui seront stockés dans la variable \textbf{p}.

\item \textbf{Spécifier les paramètres}
 \begin{lstlisting}[style=cypher]
MATCH p = AllShortestPaths((A:Station)-[*..20]->(B:Station))
WHERE A.name = {startParam} AND B.name = {endParam}
	AND ALL(rel IN relationships(p) 
					WHERE type(rel) IN {transportsParam})
\end{lstlisting}
Dans cette partie nous spécifions les paramètres de la requête, à commencer par désigner le nom des stations A (startParam) et B (endParam), et assurer que les types d'arcs du chemin sont ceux donnés dans \emph{transportParam}.

\item \textbf{Mettre en forme le résultat :}
 \begin{lstlisting}[style=cypher]
WITH p, RELATIONSHIPS(p) as segments
WITH EXTRACT (segment in segments| StartNode(segment)) AS startNodes,
EXTRACT (segment in segments| EndNode(segment)) AS endNodes,
RELATIONSHIPS(p) as segments

RETURN segments, startNodes, endNodes

\end{lstlisting}

Afin de faciliter le traitement et lecture du chemin retournée dans l'application, Neo4j extrait les stations de départ, d'arrivée et les arcs composant ce chemin  avant de les retourner séparément.
\end{itemize}

%
%\begin{figure}
% \begin{lstlisting}[style=cypher]
%MATCH p = AllShortestPaths((A:Station)-[*..20]->(B:Station))
%WHERE A.name = {startParam} AND B.name = {endParam}
%	AND ALL(rel IN relationships(p) 
%					WHERE type(rel) IN {transportsParam})
%
%WITH p, RELATIONSHIPS(p) as segments
%WITH EXTRACT (segment in segments| StartNode(segment)) AS startNodes,
%EXTRACT (segment in segments| EndNode(segment)) AS endNodes,
%RELATIONSHIPS(p) as segments
%            
%RETURN segments, startNodes, endNodes
%\end{lstlisting}
%\caption{Requete Cypher de recherche de chemin}
%\label{fig:cypherquery}
%\end{figure}

\subsection{Format des réponses}
\label{ref:formatReponse}
L'API retourne un tableau des chemins (tableau d'objets Path) en format JSON, ces objets contiennent les informations suivantes :

\begin{itemize}
	\item Le temps, prix et distance totale du chemin.
	\item Les moyens de transport utilisés dans ce chemin.
	\item La liste des étapes à suivre dans ce chemin, chaque étape contenant les données suivantes:
	      \begin{itemize}
	      	\item La station de départ et la station d'arrivée.
	      	\item Les stations intermédiaires entre station de départ et d'arrivée.
	      	\item Le prix, temps estimés et distance à parcourir de l'étape.
	      	\item Le transport à prendre (ou type de l'étape).
	      \end{itemize}
\end{itemize}
La figure \ref{fig:JSONPath} donne un exemple d'une réponse en JSON d'un itinéraire entre l'université USTO et un arrêt à Dar el Beida.

\begin{figure}[ht]
\begin{lstlisting}[]
[
  {
    "totalDistance":4850,	// en metres
    "totalPrice":20,				// en DA
    "totalTime":29,				// en minutes
    "totalWalkTime":3,		// en minutes
    "transportTypes":[		// les transports a utiliser dans ce chemin
      "Bus",
      "Marche"
    ],
    "steps":[							// Tableau d'etapes
      {
        "from":{						// station de depart
          "ID":1,
          "name":"Arret universite USTO",
          "address":"Rue Aies Ben Ahmed, Bir El Djir, Algerie",
          "coord":{
            "lat":35.70403889560459,
            "lon":-0.5774994712808166
          }
        },
        "intermediate":[...],  // Tableaux de stations a passer
        "to":{ 								// Derniere station de l'etape
          ....	 
        },
        "price":0,
        "dist":4600,
        "time":26,
        "type":"Bus",
        "name":"4G"
      },
      {
        "from":{
          ...
        },
        "intermediate":[],
        "to":{
          "ID":0,
          "name":"Mosquee El Feth, Dar el Beida",
          "address":"3eme Boulevard Peripherique, Oran, Algerie",
          "coord":{
            "lat":35.69603651865668,
            "lon":-0.612222810195135
          }
        },
        "price":0,
        "dist":250,
        "time":3,
        "type":"Marche",
      }
    ]
  }
]
\end{lstlisting}
\caption{Format JSON de Path (chemin)}
\label{fig:JSONPath}
\end{figure}

\section{Applications Front-End}
\label{ref:Implementation}

La partie front end du projet qui communique avec le service web a été divisée en deux parties: une application client et une application administrateur.
\subsection{Application client}

La partie client consiste en une application web qui présente le service, et offre une interface aux utilisateurs pour saisir leurs requêtes et critères, puis visualiser les résultats à l'aide d'une carte.
Elle peut évoluer en une application complète en ajoutant des sections d'orientations, des informations sur les lignes...etc.

Les interfaces de l'application client sont donnés dans les figures \ref{fig:clientInterface}, \ref{fig:clientInterface2} et \ref{fig:clientInterface3}.

\begin{figure}[h!]

	 \begin{subfigure}[b]{\linewidth}
	 	\includegraphics[width=\linewidth]{img/spuf/acceuil.png}
	 	\caption{Page d'accueil.}
	 \end{subfigure}
	 
	 \begin{subfigure}[b]{\linewidth}
	 	\includegraphics[width=\linewidth]{img/spuf/request.png}
	 	\caption{Page de requête.}	 
	 \end{subfigure}
	 
	\caption{Aperçu de l'application client.}
	 \label{fig:clientInterface}
\end{figure}


\begin{figure}
	 \begin{subfigure}[b]{\linewidth}
	 	\includegraphics[width=\linewidth]{img/spuf/response.png}
	 	\caption{Page de réponse.}
	 \end{subfigure}
	 
	 \begin{subfigure}[b]{\linewidth}
	 	\includegraphics[width=\linewidth]{img/spuf/response2.png}
	 	\caption{Page de réponse détaillée.}	 
	 \end{subfigure}
	 \caption{Aperçu de l'application client.}
	 \label{fig:clientInterface2}
\end{figure}

\begin{figure}
	 \begin{subfigure}[b]{\linewidth}
	 	\includegraphics[width=\linewidth]{img/spuf/infobus.png}
	 	\caption{Page d'informations (bus).}
	 \end{subfigure}
	 
	 \begin{subfigure}[b]{\linewidth}
	 	\includegraphics[width=\linewidth]{img/spuf/infotram.png}
	 	\caption{Page d'informations (Tramway).}	 
	 \end{subfigure}
	 \caption{Aperçu de l'application client.}
	 \label{fig:clientInterface3}
\end{figure}

\subsection{Application administrateur}
La partie administrateur consiste en une application web indépendante de l'application client, elle permet d'introduire de nouvelles stations et lignes avec les différentes informations de chacune.
Elle peut être complétée en ajoutant d'autres menus pour différents transports par exemple ou plus de fonctionnalités permettant d'ajouter plus facilement un grand nombre d'informations.\newline
Les interfaces de l'application administrateur sont donnés dans les figures \ref{fig:adminInterface} et \ref{fig:adminInterface2}.
\begin{figure}[h!]
	 \begin{subfigure}[b]{\linewidth}
	 	\includegraphics[width=\linewidth]{img/spuf/adminmenu.png}
	 	\caption{Page acceuil.}
	 \end{subfigure}
	 
	 \begin{subfigure}[b]{\linewidth}
	 	\includegraphics[width=\linewidth]{img/spuf/addline.png}
	 	\caption{Page ajout de nouvelles lignes.}
	 \end{subfigure}
	 \caption{Aperçu de l'application administrateur.}
	 \label{fig:adminInterface}
\end{figure}

\begin{figure}[h!]
	 \begin{subfigure}[b]{\linewidth}
	 	\includegraphics[width=\linewidth]{img/spuf/stationadd.png}
	 	\caption{Page ajout de nouvelles lignes.}	 
	 \end{subfigure}
	 
	 \begin{subfigure}[b]{\linewidth}
	 	\includegraphics[width=\linewidth]{img/spuf/createstation.png}
	 	\caption{Page ajout de nouvelle station.}	 
	 \end{subfigure}
	 \caption{Aperçu de l'application administrateur.}
	 \label{fig:adminInterface2}
\end{figure}